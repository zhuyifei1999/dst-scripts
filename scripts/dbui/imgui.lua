-- A wrapper for exposing imgui API to lua.
--
-- Instead of exposing the C API generated by imgui_iterator directly, we do it
-- through this file to protect ourselves changes and bad names due to
-- generated code.
--
-- Lua doesn't support overloading, but we can simulate it by making functions
-- that accept all the args and check if some were nil.

require "util"

local function PushStyleVar(style_index, val_or_x, nil_or_y)
    assert(style_index ~= nil)
    assert(val_or_x ~= nil)
    if nil_or_y == nil then
        --    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, float val);
        return imguiraw.PushStyleVar(style_index, val_or_x)
    else
        --    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);
        return imguiraw.PushStyleVar_2(style_index, val_or_x, nil_or_y)
    end
end

local function GetColorU32(col_index_or_v0, alpha_mul_or_v1, nil_or_v2, nil_or_v3)
    assert(col_index_or_v0 ~= nil)
    if nil_or_v2 == nil then
        --    IMGUI_API ImU32         GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);                  // retrieve given style color with style alpha applied and optional extra alpha multiplier
        return imguiraw.GetColorU32(col_index_or_v0, alpha_mul_or_v1)
    else
        --    IMGUI_API ImU32         GetColorU32(const ImVec4& col);                                     // retrieve given color with style alpha applied
        return imguiraw.GetColorU32_1(col_index_or_v0, alpha_mul_or_v1, nil_or_v2, nil_or_v3)
    end
end


local function PushID(int_or_str_id, nil_or_end)
    assert(int_or_str_id ~= nil)
    if nil_or_end == nil then
        if type(int_or_str_id) == "string" then
            --    IMGUI_API void          PushID(const char* str_id);                                         // push identifier into the ID stack. IDs are hash of the *entire* stack!
            return imguiraw.PushID(int_or_str_id)
        else
            --    IMGUI_API void          PushID(int int_id);
            return imguiraw.PushID_1(int_or_str_id)
        end
    else
        --    IMGUI_API void          PushID(const char* str_id_begin, const char* str_id_end);
        return imguiraw.PushID_2(int_or_str_id, nil_or_end)
    end
end

local function GetID(str_id, nil_or_id_end)
    assert(str_id ~= nil)
    if nil_or_id_end == nil then
        --    IMGUI_API ImGuiID       GetID(const char* str_id);                                          // calculate unique ID (hash of whole ID stack + given parameter). useful if you want to query into ImGuiStorage yourself. otherwise rarely needed
        return imguiraw.GetID(str_id)
    else
        --    IMGUI_API ImGuiID       GetID(const char* str_id_begin, const char* str_id_end);
        return imguiraw.GetID_2(str_id, nil_or_id_end)
    end
end

local function RadioButton(label, active_or_v, nil_or_v_button)
    assert(label ~= nil)
    assert(active_or_v ~= nil)
    if nil_or_v_button == nil then
        --    IMGUI_API bool          RadioButton(const char* label, bool active);
        return imguiraw.RadioButton(label, active_or_v)
    else
        --    IMGUI_API bool          RadioButton(const char* label, int* v, int v_button);
        return imguiraw.RadioButton_3(label, active_or_v, nil_or_v_button)
    end
end

local function TreeNode(label_or_id, nil_or_fmt, nil_or_varargs)
    assert(label_or_id ~= nil)
    if nil_or_fmt == nil then
        --    IMGUI_API bool          TreeNode(const char* label);                                            // if returning 'true' the node is open and the tree id is pushed into the id stack. user is responsible for calling TreePop().
        return imguiraw.TreeNode(label_or_id)
    else
        --    IMGUI_API bool          TreeNode(const char* str_id, const char* fmt, ...);    // read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().
        return imguiraw.TreeNode_3(label_or_id, nil_or_fmt, nil_or_varargs)
    end
end


local function Value(prefix, value, nil_or_fmt)
    assert(prefix ~= nil)
    assert(value ~= nil)
    local value_t = type(value)
    if nil_or_fmt == nil then
        if value_t == "boolean" then
            --    IMGUI_API void          Value(const char* prefix, bool b);
            return imguiraw.Value(prefix, value)
        elseif value_t == "number" then
            --    IMGUI_API void          Value(const char* prefix, int v);
            return imguiraw.Value_2(prefix, value)
        else
            assert(false, "Value() only accepts booleans and numbers")
        end
    else
        --    IMGUI_API void          Value(const char* prefix, float v, const char* float_format = NULL);
        return imguiraw.Value_3(prefix, value, nil_or_fmt)
    end
end

local function ValueColor(prefix, value_or_v0, nil_or_v1, nil_or_v2, nil_or_v3)
    assert(prefix ~= nil)
    assert(value_or_v0 ~= nil)
    if nil_or_v1 == nil then
        --    IMGUI_API void          ValueColor(const char* prefix, ImU32 v);
        return imguiraw.ValueColor_2(prefix, value_or_v0)
    else
        --    IMGUI_API void          ValueColor(const char* prefix, const ImVec4& v);
        return imguiraw.ValueColor(prefix, value_or_v0, nil_or_v1, nil_or_v2, nil_or_v3)
    end
end

local function IsRectVisible(size_or_min_x, size_or_min_y, nil_or_max_x, nil_or_max_y)
    if nil_or_max_x == nil then
        --    IMGUI_API bool          IsRectVisible(const ImVec2& size);                                  // test if rectangle (of given size, starting from cursor position) is visible / not clipped.
        return imguiraw.IsRectVisible(size_or_min_x, size_or_min_y)
    else
        --    IMGUI_API bool          IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max);      // test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.
        return imguiraw.IsRectVisible_2(size_or_min_x, size_or_min_y, nil_or_max_x, nil_or_max_y)
    end
end


-- Modify the default API to support our overloading. For the most part, you
-- can look at imgui.h to see how functions work. You can look at
-- imgui_iterator.inl to see what functions aren't supported.
--
-- enums are exposed through imgui.constant: ImGuiWindowFlags_NoScrollbar
-- becomes imgui.constant.WindowFlags.NoScrollbar
local imgui = shallowcopy(imguiraw)

-- Removed Begin_5 - obsolete
imgui.Begin_5                 = nil

-- Renamed BeginChild_4 - disambiguation
imgui.BeginChild_WithId       = imguiraw.BeginChild_4
imgui.BeginChild_4            = nil

-- Renamed SetWindowPos_3 to SetWindowPos - original is not recommended
-- Renamed SetWindowSize_3 to SetWindowSize - original is not recommended
-- Renamed SetWindowCollapsed_3 to SetWindowCollapsed - original is not recommended
-- Renamed SetWindowFocus_1 to SetWindowFocus - original is not recommended
imgui.SetWindowPos            = imguiraw.SetWindowPos_3
imgui.SetWindowSize           = imguiraw.SetWindowSize_3
imgui.SetWindowCollapsed      = imguiraw.SetWindowCollapsed_3
imgui.SetWindowFocus          = imguiraw.SetWindowFocus_1
imgui.SetWindowPos_3          = nil
imgui.SetWindowSize_3         = nil
imgui.SetWindowCollapsed_3    = nil
imgui.SetWindowFocus_1        = nil

-- Combined PushStyleVar_2 with PushStyleVar
imgui.PushStyleVar            = PushStyleVar
imgui.PushStyleVar_2          = nil

-- Combined GetColorU32_1 with GetColorU32
imgui.GetColorU32             = GetColorU32
imgui.GetColorU32_1           = nil

-- Combined PushID_1 with PushID
-- Combined PushID_2 with PushID
imgui.PushID                  = PushID
imgui.PushID_1                = nil
imgui.PushID_2                = nil


-- Combined GetID_2 with GetID
imgui.GetID                   = GetID
imgui.GetID_2                 = nil

-- Combined RadioButton_3 with RadioButton
imgui.RadioButton             = RadioButton
imgui.RadioButton_3           = nil

-- Combined TreeNode_3 with TreeNode
imgui.TreeNode                = TreeNode
imgui.TreeNode_3              = nil

-- Removed Selectable - too much state required
imgui.Selectable              = imguiraw.Selectable_4
imgui.Selectable_4            = nil

-- Renamed ListBoxHeader - disambiguation
imgui.ListBoxHeader_WithSize  = imguiraw.ListBoxHeader
imgui.ListBoxHeader_WithCount = imguiraw.ListBoxHeader_3
imgui.ListBoxHeader           = nil
imgui.ListBoxHeader_3         = nil

-- Combined Value_2 with Value
-- Combined Value_3 with Value
imgui.Value                   = Value
imgui.Value_2                 = nil
imgui.Value_3                 = nil
-- Renamed Value_2_2 - disambiguation
imgui.Value_Unsigned          = imguiraw.Value_2_2

-- Combined ValueColor_2 with ValueColor
imgui.ValueColor              = ValueColor
imgui.ValueColor_2            = nil

-- Removed MenuItem_4 - not useful without pass-by-ref
imgui.MenuItem_4              = nil

-- Combined IsRectVisible_2 with IsRectVisible
imgui.IsRectVisible           = IsRectVisible
imgui.IsRectVisible_2         = nil



-- Also bind ImguiLuaProxy.
--
-- Bind on top of what's provided by imgui_lua_bindings with the assumption
-- that we're intentionally overriding existing functions.

-- Strip class-ness from TheRawImgui.
--
-- TheRawImgui is a class, but imgui_lua_bindings uses functions namespaced in
-- a table. Strip the class-ness from TheRawImgui to maintain a uniform
-- interface. Bind the member functions from RawImgui and return a closure that
-- invokes the member function. lua doesn't have automatic call-site argpacking
-- so support up to 10 arguments.
function binder(singleton, destination)
    return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
        return destination(singleton, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)
    end
end
for key,val in pairs(RawImgui) do
    imgui[key] = binder(TheRawImgui, val)
end

-- Ensure we never call into imgui from lua if it's disabled.
--
-- Users can still call imgui functions, but they won't invoke any imgui code.
-- This no-op behavior should help ensure mods don't easily break.
if not imgui.IsImguiEnabled() then
    local function DoNothing()
        print("imgui is disabled in this build")
        -- Returning false should fail anything checking Begin() or most other
        -- return value checks.
        return false
    end
    for key,val in pairs(imgui) do
        -- Only clean functions so references to constants don't cause lua
        -- errors.
        if type(val) == 'function' then
            imgui[key] = DoNothing
        end
    end
end

-- Users can just use imgui and their code will do nothing if it's disabled.
imgui.IsImguiEnabled = nil

return imgui
